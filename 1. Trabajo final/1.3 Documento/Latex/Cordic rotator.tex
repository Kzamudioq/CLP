% Created 2020-04-24 vie 23:03
% Intended LaTeX compiler: pdflatex
\documentclass[12pt,a4paper, twoside]{article} % "twoside" en lugar de "twosite"
\usepackage[utf8]{inputenc}
\usepackage{pgf-umlcd}
\usepackage{lscape}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xparse}
\usetikzlibrary{positioning, arrows.meta, shapes}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{apalike}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{capt-of}
\usepackage[spanish]{babel}

\usepackage{listings}
\let\bibhang\relax  % Elimina la definición previa de \bibhang
\usepackage[numbers]{natbib}
\usepackage{hyperref}
\usepackage[left=2.00cm, right=2.50cm, top=2.50cm, bottom=2.00cm]{geometry}
\usepackage{fancyhdr}
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO]{\emph{\uppercase{\leftmark}}}
\fancyfoot{}
\renewcommand{\headrulewidth}{1.0pt}
\pagestyle{fancy}
\date{}
\title{Circuitos lógicos programables}
\hypersetup{
    pdfauthor={},
    pdftitle={Testing de software en sistemas embebidos},
    pdfkeywords={},
    pdfsubject={},
    pdfcreator={Emacs 26.2 (Org mode 9.1.9)},
    pdflang={ spanish }
}

\linespread{1.5}

\begin{document}

\renewcommand\refname{}
\renewcommand{\contentsname}{Tabla de contenido}
\newpage

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

                \includegraphics[width=1\textwidth]{Figuras/logoFIUBA.pdf} % Ruta al logo de FIUBA

        \vspace{1.5cm}

        \textbf{\LARGE CORDIC modo rotador}

        \vspace{4cm}
        \textbf{\Large Circuitos lógicos programables}

        \vspace{1.5cm}


        \textbf{\Large Escrito por:}\\
        \large Karen Tatiana Zamudio

        \vspace{0.8cm}

        \textbf{\Large Revisión A}\\
        \large Nicolas Álvarez

        \vfill

        \textbf{\Large Universidad de Buenos Aires}\\
        \vspace{0.2cm}

        \large  11 abril 2024

    \end{center}
\end{titlepage}
\newpage

\section*{Historial de cambios}
\label{sec:registro}

\begin{table}[ht]
  \centering
  \caption{Registro de Revisiones}
  \label{tab:registro}
  \begin{tabularx}{\linewidth}{|c|X|c|}
    \hline
    Revisión & Detalles de los cambios realizados & Fecha \\
    \hline
    0 & Creación del documento & \ 11 de abril 2024 \\
    \hline
    1 & Entrega  & \ 23 de abril 2024 \\
    \hline
  \end{tabularx}
\end{table}

\maketitle
\tableofcontents

\newpage

\section{Introducción}
\label{sec:org60390fa}

En el contexto del diseño digital y la implementación de algoritmos, el presente documento aborda la creación y análisis de un módulo de rotación basado en el algoritmo CORDIC (Coordinate Rotation Digital Computer). El algoritmo CORDIC es ampliamente utilizado en sistemas digitales para calcular funciones trigonométricas y transformaciones de coordenadas de manera eficiente.

Este documento proporcionará una visión general del diseño del módulo cordic rotator, destacando su funcionamiento, estructura interna y su implementación en una FPGA (Field-Programmable Gate Array). Además, se presentarán los resultados de simulaciones y se analizará el uso de recursos de la FPGA.


\subsection{Objetivos}
\label{subsec:org12e44a2}

Analizar y documentar el diseño, implementación y funcionamiento del módulo cordic rotator basado en el algoritmo CORDIC, así como evaluar su eficiencia y aplicabilidad en sistemas digitales.

\begin{enumerate}

\item Describir el algoritmo CORDIC y su aplicación en rotación de coordenadas: proporcionar una explicación detallada del algoritmo CORDIC y cómo se utiliza para realizar rotaciones de coordenadas cartesianas en el diseño del módulo cordic rotator.

\item Implementar el módulo cordic rotator en Verilog: crear una implementación en Verilog del módulo cordic rotator, asegurando que el código refleje correctamente la lógica del algoritmo CORDIC y que sea adecuado para su uso en sistemas digitales.

\item Realizar simulaciones del módulo y analizar su comportamiento: ejecutar simulaciones del módulo cordic rotator en un entorno de simulación, utilizando diferentes casos de prueba para evaluar su funcionamiento en una variedad de escenarios. Analizar los resultados de las simulaciones para verificar la precisión y eficacia del diseño.

\item Evaluar el uso de recursos de la FPGA: realizar un análisis exhaustivo del uso de recursos de la FPGA por parte del diseño del módulo cordic rotator, incluyendo el número de LUTs, FFs y otros recursos utilizados. Identificar áreas de mejora en términos de eficiencia y optimización del diseño.

\end{enumerate}


\subsection{Alcance}
\label{subsec:org12e44a2}

El alcance de este documento abarca la descripción detallada del diseño e implementación del módulo cordic rotator utilizando el algoritmo CORDIC en Verilog. Se incluirá una explicación exhaustiva del funcionamiento del algoritmo CORDIC y su aplicación en la rotación de coordenadas cartesianas. Además, se proporcionará el código Verilog del módulo cordic rotator junto con explicaciones detalladas de su estructura interna y su funcionamiento.

 Se realizarán simulaciones del módulo en un entorno adecuado para evaluar su comportamiento en diversos escenarios, y se analizarán los resultados obtenidos. Asimismo, se llevará a cabo un análisis del uso de recursos de la FPGA por parte del diseño, con el objetivo de evaluar su eficiencia y escalabilidad en sistemas digitales.


\section{CORDIC}
\label{sec:orgc1c4017}

CORDIC (Coordinate Rotation Digital Computer) es un algoritmo utilizado para calcular funciones trigonométricas, como seno, coseno, arcotangente, y para realizar rotaciones y transformaciones de coordenadas de manera eficiente en sistemas digitales. Fue desarrollado en la década de 1950 por Jack E. Volder en Bell Labs.

El algoritmo CORDIC se basa en una serie de rotaciones y desplazamientos sucesivos que permiten aproximar funciones trigonométricas y realizar operaciones de rotación con un bajo costo computacional. Una de las características clave del algoritmo CORDIC es su capacidad para realizar estas operaciones utilizando únicamente operaciones de suma, resta y desplazamiento bit a bit, lo que lo hace adecuado para implementaciones en hardware digital.

El algoritmo CORDIC es especialmente útil en aplicaciones donde se requieren cálculos trigonométricos rápidos y precisos, como en sistemas de procesamiento de señales, sistemas de comunicación digital, gráficos por computadora, entre otros. Además, es altamente versátil y puede adaptarse para calcular una amplia gama de funciones trigonométricas y realizar diversas operaciones geométricas.



\subsection{CORDIC trigonométrico}
\label{sec:orgdaca22c}


El algoritmo CORDIC (Coordinate Rotation Digital Computer) Trigonométrico es un método iterativo utilizado para calcular funciones trigonométricas como el seno ($\sin$), coseno ($\cos$), arcoseno ($\arcsin$) y arcocoseno ($\arccos$). Funciona mediante iteraciones de rotación y desplazamiento, donde cada iteración aproxima gradualmente el valor deseado de la función trigonométrica. El algoritmo se basa en la representación de un ángulo en coordenadas cartesianas $(X, Y)$ y utiliza rotaciones sucesivas para acercarse al ángulo objetivo. A medida que las iteraciones continúan, el valor de salida converge hacia el valor correcto con una precisión determinada.

En cada iteración del algoritmo CORDIC Trigonométrico, se realiza una rotación y un desplazamiento de las coordenadas $(X, Y)$. La rotación se realiza mediante el ajuste de los ángulos de las coordenadas, lo que permite acercarse al ángulo objetivo. El desplazamiento se utiliza para ajustar las magnitudes de las coordenadas y garantizar que la convergencia del algoritmo sea adecuada. Estas iteraciones se repiten hasta que se alcanza la precisión deseada en el cálculo de la función trigonométrica.

Por ejemplo, para calcular el seno de un ángulo dado utilizando el algoritmo CORDIC Trigonométrico, se inicializan las coordenadas $(X, Y)$ con valores apropiados y se realizan iteraciones de rotación y desplazamiento hasta que se alcanza la precisión deseada. El valor de $Y$ al final de las iteraciones representa el valor aproximado del seno del ángulo dado. De manera similar, se pueden calcular el coseno, el arcoseno y el arcocoseno utilizando adaptaciones del algoritmo CORDIC Trigonométrico.

La precisión y la convergencia del algoritmo CORDIC Trigonométrico dependen del número de iteraciones realizadas y del número de bits utilizados para representar los valores de las coordenadas. En general, el algoritmo converge rápidamente y proporciona resultados precisos con un número suficiente de iteraciones. Sin embargo, la precisión puede verse afectada por la representación finita de los números en sistemas digitales y por la resolución de las operaciones de rotación y desplazamiento.

El algoritmo CORDIC trigonométrico se utiliza en una amplia gama de aplicaciones en sistemas digitales, incluyendo procesamiento de señales, comunicaciones, gráficos por computadora, sistemas de navegación y más. Se utiliza para calcular funciones trigonométricas de manera eficiente y precisa en sistemas donde se requieren cálculos frecuentes de ángulos y funciones trigonométricas. Su implementación en hardware digital es especialmente adecuada debido a su simplicidad y eficiencia en términos de recursos computacionales.

Las ecuaciones para las iteraciones de rotación y desplazamiento en el algoritmo CORDIC Trigonométrico pueden ser expresadas como:

\begin{equation}
    \begin{aligned}
        X_{i+1} &= X_i - \delta_i \cdot Y_i \cdot 2^{-i}, \\
        Y_{i+1} &= Y_i + \delta_i \cdot X_i \cdot 2^{-i}, \\
        Z_{i+1} &= Z_i - \delta_i \cdot \text{atanh}(2^{-i}),
    \end{aligned}
\end{equation}

donde $i$ es el índice de iteración, $\delta_i$ es el signo de la rotación en la iteración $i$, $X_i$, $Y_i$ son las coordenadas en la iteración $i$, y $Z_i$ es el ángulo acumulado hasta la iteración $i$.  



\subsection{CORDIC vectorial}
\label{sec:orgdaca22c}


El algoritmo CORDIC Vectorial utiliza un enfoque similar al CORDIC Trigonométrico, pero se enfoca en manipular vectores en lugar de solo ángulos. Permite realizar rotaciones y transformaciones de coordenadas en sistemas de coordenadas cartesianas o polares de manera eficiente. 

En un sistema de coordenadas cartesianas, las operaciones del CORDIC Vectorial pueden utilizarse para rotar un vector en el plano XY. Por otro lado, en un sistema de coordenadas polares, el algoritmo puede utilizarse para convertir coordenadas cartesianas a polares y viceversa, así como para realizar rotaciones de vectores en el plano radial.

La eficiencia y precisión del CORDIC Vectorial lo hacen adecuado para una variedad de aplicaciones en sistemas digitales, como procesamiento de señales, modulación y demodulación en sistemas de comunicaciones, y transformaciones geométricas en gráficos por computadora. Además, su estructura iterativa permite su implementación eficiente en hardware digital, lo que lo convierte en una opción popular en sistemas embebidos y sistemas de tiempo real donde los recursos son limitados.


\subsection{CORDIC logarítmico}
\label{sec:orgdaca22c}

El algoritmo CORDIC logarítmico utiliza una serie de iteraciones para aproximar funciones logarítmicas y exponenciales, así como operaciones relacionadas como la raíz cuadrada y el exponente. A través de un proceso iterativo, el algoritmo calcula las aproximaciones de estas funciones con una precisión deseada.

Una de las características clave del CORDIC logarítmico es su capacidad para calcular estas funciones de manera eficiente y precisa utilizando un enfoque iterativo y estructuras de datos simples. Esto lo hace adecuado para su implementación en sistemas digitales donde se requieren cálculos de funciones no trigonométricas con recursos limitados.

El CORDIC logarítmico tiene una amplia gama de aplicaciones en sistemas digitales, incluyendo procesamiento de señales, compresión de datos, criptografía y más. Se utiliza en situaciones donde se requiere el cálculo rápido y preciso de funciones logarítmicas y exponenciales, así como operaciones relacionadas como la raíz cuadrada y el exponente. Su eficiencia y precisión lo hacen valioso en una variedad de aplicaciones de sistemas digitales.





\section{Implementación CORDIC rotator}
\label{sec:orgc1c4017}

En esta sección, se detalla la implementación del módulo CORDIC Rotator en Verilog. El módulo CORDIC Rotator es una implementación hardware del algoritmo CORDIC (Coordinate Rotation Digital Computer), diseñado para realizar rotaciones de vectores en el plano cartesiano. El algoritmo CORDIC se utiliza ampliamente en sistemas digitales para calcular funciones trigonométricas, transformaciones de coordenadas y otras operaciones matemáticas de manera eficiente. En esta sección, se explicará paso a paso la implementación del módulo CORDIC rotator, incluyendo la configuración de parámetros, la definición de la tabla de arco tangente, las iteraciones del algoritmo y la salida del módulo. Cada parte de la implementación se analizará en detalle, acompañada de su correspondiente código en Verilog.

\subsection{Configuración de Tiempo y Declaración de Módulo}

El código comienza con la configuración del \texttt{timescale} y la definición de parámetros utilizados en el módulo. El parámetro \texttt{c parameter} determina el ancho de bits de los datos de entrada y salida, mientras que \texttt{STG} se utiliza para definir el ancho de bits de los vectores \texttt{X} e \texttt{Y}. Luego, se declara el módulo \texttt{cordic rotator} con sus entradas (\texttt{clock}, \texttt{angle}, \texttt{Xin}, \texttt{Yin}) y salidas (\texttt{Xout}, \texttt{Yout}).

\begin{lstlisting}[language=Verilog]
`timescale 1ns/100ps

module cordic_rotator (
    input clock,
    input signed [31:0] angle,
    input signed [c_parameter - 1:0] Xin,
    input signed [c_parameter - 1:0] Yin,
    output signed [c_parameter:0] Xout,
    output signed [c_parameter:0] Yout
);

parameter c_parameter = 16;
localparam STG = c_parameter;
\end{lstlisting}

\subsection{Declaración de la Tabla \texttt{atan\_table}}

La tabla \texttt{atan\_table} contiene los valores de la función arco tangente utilizados en el algoritmo CORDIC. Estos valores están precalculados y se utilizan para realizar las operaciones de rotación en el módulo. La tabla está definida como un arreglo de 31 bits con 31 entradas, cada una representando un ángulo específico.

\begin{lstlisting}[language=Verilog]

wire signed [31:0] atan_table [0:30];
assign atan_table[00] = 32'b00100000000000000000000000000000; 
// Resto de asignaciones de la tabla atan_table...

\end{lstlisting}

\subsection{Inicialización de registros y asignación de cuadrante}

Se inicializan los registros \texttt{X}, \texttt{Y} y \texttt{Z}, que se utilizan para almacenar los datos en cada etapa del algoritmo CORDIC. Luego, se calcula el cuadrante en el que se encuentra el ángulo de rotación para determinar cómo se deben tratar los datos de entrada.

\subsubsection{Cuadrante I}

En el cuadrante I, el ángulo de rotación se encuentra en el rango de 0 a $\pi$/2. En este caso, no es necesario realizar ninguna modificación en los datos de entrada, ya que están en el rango adecuado para ser procesados por el algoritmo CORDIC. Por lo tanto, los valores de las coordenadas X e Y del vector de entrada (\texttt{Xin} y \texttt{Yin}) se asignan directamente a los registros \texttt{X[0]} y \texttt{Y[0]}, respectivamente. Además, el ángulo de rotación (\texttt{angle}) se asigna directamente al registro \texttt{Z[0]}.

\begin{lstlisting}[language=Verilog]
       case (quadrant)
           2'b00: begin // Cuadrante I
               X[0] <=   Xin;
               Y[0] <=   Yin;
               Z[0] <=   angle;
\end{lstlisting}

Este caso se activa cuando los bits de signo del ángulo son 0, indicando que el ángulo se encuentra en el primer cuadrante.

\subsubsection{Cuadrante II}

En el cuadrante II, el ángulo de rotación se encuentra en el rango de $\pi$/2 a $\pi$. Para ajustar los datos de entrada al rango adecuado para el algoritmo CORDIC, se realiza una pre-rotación del ángulo. En este caso, el ángulo se resta de $\pi$ para asegurar que esté dentro del rango de -$\pi$/2 a 0. Los valores de las coordenadas X e Y del vector de entrada se asignan a los registros \texttt{X[0]} y \texttt{Y[0]}, respectivamente, de la misma manera que en el cuadrante I.

\begin{lstlisting}[language=Verilog]
       2'b01: begin // Cuadrante II
               X[0] <=    Xin;
               Y[0] <=    Yin;
               Z[0] <=  32'b10000000000000000000000000000000 - angle;                  
\end{lstlisting}

Este caso se activa cuando el bit de signo más significativo del ángulo es 0 y el siguiente bit es 1, indicando que el ángulo se encuentra en el segundo cuadrante.

\subsubsection{Cuadrante III}

En el cuadrante III, el ángulo de rotación se encuentra en el rango de -$\pi$ a -$\pi$/2. Al igual que en el cuadrante II, se realiza una pre-rotación del ángulo restando $\pi$ para asegurar que esté dentro del rango de -$\pi$/2 a 0. Los valores de las coordenadas X e Y del vector de entrada se asignan a los registros \texttt{X[0]} y \texttt{Y[0]}, respectivamente, de la misma manera que en los cuadrantes I y II.

\begin{lstlisting}[language=Verilog]
       2'b10: begin // Cuadrante III
               X[0] <=    Xin;
               Y[0] <=    Yin;
               Z[0] <=    angle - 32'b10000000000000000000000000000000; 
\end{lstlisting}

Este caso se activa cuando el bit de signo más significativo del ángulo es 1 y el siguiente bit es 0, indicando que el ángulo se encuentra en el tercer cuadrante.

\subsubsection{Cuadrante IV}

En el cuadrante IV, el ángulo de rotación se encuentra en el rango de -$\pi$/2 a 0. Para ajustar los datos de entrada al rango adecuado para el algoritmo CORDIC, se realiza una pre-rotación del ángulo restando 2$\pi$ para asegurar que esté dentro del rango de -$\pi$/2 a -$\pi$. Los valores de las coordenadas X e Y del vector de entrada se asignan a los registros \texttt{X[0]} y \texttt{Y[0]}, respectivamente, de la misma manera que en los cuadrantes I, II y III.


\begin{lstlisting}[language=Verilog]
       2'b10: begin // Cuadrante III
               X[0] <=    Xin;
               Y[0] <=    Yin;
               Z[0] <=    angle - 32'b10000000000000000000000000000000; 
\end{lstlisting}

Este caso se activa cuando los bits de signo del ángulo son 1, indicando que el ángulo se encuentra en el cuarto cuadrante.



\subsection{Banco de pruebas}

El banco de pruebas proporcionado se encarga de simular el módulo \texttt{cordic\_rotator} y generar formas de onda de entrada para probar su funcionalidad. Aquí tienes una explicación detallada de su funcionamiento:

\subsubsection{Parámetros y variables locales}
Se definen algunos parámetros y variables locales para el tamaño de los datos de entrada (\texttt{SZ}), los valores booleanos (\texttt{FALSE} y \texttt{TRUE}), y el valor de la señal de entrada (\texttt{VALUE}), que se reduce para ajustarse a la ganancia del sistema.

\begin{lstlisting}[language=Verilog]

localparam SZ = 16; 

reg [SZ-1:0] Xin, Yin;
reg [31:0] angle;
wire [SZ:0] Xout, Yout;
reg CLK_100MHZ;

localparam FALSE = 1'b0;
localparam TRUE = 1'b1;

// reducido por un factor de 1.647 ya que es la ganancia del sistema (k)
localparam VALUE = 32000/1.647; 

\end{lstlisting}

\subsubsection{Inicialización}
Antes de comenzar la simulación, se inicializan las variables y las señales de entrada. Se establece \texttt{start} en \texttt{FALSE}, se inicializa la señal de reloj \texttt{CLK\_100MHZ}, el ángulo en cero, y se establece un valor inicial para \texttt{Xin} y \texttt{Yin}.

\begin{lstlisting}[language=Verilog]
initial
begin
    start = FALSE;
    CLK_100MHZ = 1'b0;
    angle = 0;
    Xin = VALUE;
    Yin = 1'd0;
    i = 0;
  
    #1000;
    @(posedge CLK_100MHZ);
    start = TRUE;
\end{lstlisting}

\subsubsection{Generación de formas de onda}
Durante la simulación, se genera una señal de reloj de 100 MHz (\texttt{CLK\_100MHZ}). Después de un breve período de espera, se activa \texttt{start} para indicar que la simulación comienza y se comienza a generar una secuencia de ángulos para probar el módulo \texttt{cordic\_rotator}.

\begin{lstlisting}[language=Verilog]
for (i = 0; i < 360; i = i + 1)  

begin
    @(posedge CLK_100MHZ);
    #11700
    start = FALSE;
    angle = ((1 << 32)*(i+1))/360;
end
\end{lstlisting}

\subsubsection{Generación del reloj}
Se genera una señal de reloj de 100 MHz (\texttt{CLK\_100MHZ}) con una duración de tiempo determinada por \texttt{CLK100\_SPEED}.

\begin{lstlisting}[language=Verilog]
parameter CLK100_SPEED = 10; // 100Mhz = 10nS

initial
begin
    CLK_100MHZ = 1'b0;
    $display("CLK_100MHZ iniciado");
    #5;
    forever
    begin
        #(CLK100_SPEED/2) CLK_100MHZ = 1'b1;
        #(CLK100_SPEED/2) CLK_100MHZ = 1'b0;
    end
end
\end{lstlisting}


\subsubsection{Salida del módulo}

Finalmente, se asignan las salidas \texttt{Xout} y \texttt{Yout} del módulo con los valores calculados después de completar todas las iteraciones del algoritmo CORDIC. Estas salidas representan las coordenadas rotadas del vector de entrada.

\begin{lstlisting}[language=Verilog]

        assign Xout = X[STG - 1];
        assign Yout = Y[STG - 1];

\end{lstlisting}



\subsection{Simulación}
\label{sec:orgdaca22c}


En este documento, se describe el proceso para realizar la simulación del diseño en Vivado y posteriormente generar el archivo .bit que se utilizará para la programación de la FPGA.

\subsection{Simulación en vivado}

Para realizar la simulación en Vivado, sigue estos pasos:

\begin{enumerate}
    \item \textbf{Crear un proyecto:} Abre Vivado y crea un nuevo proyecto. Selecciona la opción de crear un diseño de tipo "RTL Project" e importa los archivos fuente de tu diseño, incluyendo el código Verilog o VHDL del rotador CORDIC.

    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth,natwidth=10,natheight=14]{./Figuras/New_project.png}
    \caption{Crear nuevo proyecto en Vivado}
    \label{fig:esquema}
    \end{figure}   
    
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,natwidth=610,natheight=642]{./Figuras/add_source.png}
    \caption{IMportacion de archivos fuente}
    \label{fig:esquema}
    \end{figure} 
    
   
    
    \item \textbf{Configurar simulación:} una vez que hayas creado el proyecto. Ve a la pestaña "Flow Navigator" y selecciona "Simulation". Aquí puedes configurar las opciones de simulación, como el tipo de simulador a utilizar y los archivos de simulación a incluir.
    
    \begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{./Figuras/Run_simulacion_visual.png}
    \caption{Esquema utilizado para la simulación en Vivado}
    \label{fig:esquema}
    \end{figure}
    
    
    \item \textbf{Ejecutar la simulación:} después de configurar la simulación, ejecútala haciendo clic en el botón "Run Simulation". Vivado ejecutará la simulación y generará resultados que podrás analizar.
    

    \begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,natwidth=610,natheight=642]{./Figuras/Resultado.png}
    \caption{Esquema utilizado para implementación de Cordic}
    \label{fig:esquema}
    \end{figure}
    
\subsection{Esquema}

El esquema utilizado para conectar las entradas y salidas del rotador CORDIC durante la simulación en Vivado se muestra en la Figura \ref{fig:esquema}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,natwidth=610,natheight=642]{./Figuras/Run_simulacion_visual.png}
    \caption{Esquema utilizado para la simulación en Vivado}
    \label{fig:esquema}
\end{figure}
    
    \item \textbf{Análisis de Resultados:} Una vez completada la simulación, analiza los resultados en Vivado. Puedes revisar las formas de onda de las señales de entrada y salida, así como cualquier mensaje de advertencia o error que pueda haberse generado durante la simulación.
\end{enumerate}







Con estos pasos, habrás completado tanto la simulación del diseño en Vivado como la generación del archivo .bit para programar la FPGA.



\subsection{Generación del Archivo .bit}

Una vez que hayas completado y verificado la simulación en Vivado, puedes proceder a generar el archivo .bit para programar la FPGA. Sigue estos pasos:

\begin{enumerate}
    \item \textbf{Implementación del Diseño:} En Vivado, ve a la pestaña "Flow Navigator" y selecciona "Implementation". Aquí, ejecuta el proceso de implementación para sintetizar y asignar el diseño a los recursos de la FPGA.
    
    \item \textbf{Generación del Bitstream:} Después de completar la implementación, ve a la pestaña "Generate Bitstream" en Vivado. Ejecuta este proceso para generar el archivo .bit, que contiene la configuración del diseño para la FPGA.
    
    \item \textbf{Programación de la FPGA:} Una vez generado el archivo .bit, puedes utilizarlo para programar la FPGA. Conecta la FPGA a tu computadora y utiliza el software de programación de Vivado para cargar el archivo .bit en la FPGA.
\end{enumerate}

Con estos pasos, habrás completado tanto la simulación del diseño en Vivado como la generación del archivo .bit para programar la FPGA.

\textbf{Nota:} El trabajo desarrollado se realizó sobre una FPGA de la firma Xilinx. La placa de desarrollo utilizada es la Arty Z7-10 de la empresa Digilent.

\end{document}




\subsection{Generación del Archivo .bit}

Una vez que hayas completado y verificado la simulación en Vivado, puedes proceder a generar el archivo .bit para programar la FPGA. Sigue estos pasos:

\begin{enumerate}
    \item \textbf{Implementación del Diseño:} En Vivado, ve a la pestaña "Flow Navigator" y selecciona "Implementation". Aquí, ejecuta el proceso de implementación para sintetizar y asignar el diseño a los recursos de la FPGA.
    
    \item \textbf{Generación del Bitstream:} Después de completar la implementación, ve a la pestaña "Generate Bitstream" en Vivado. Ejecuta este proceso para generar el archivo .bit, que contiene la configuración del diseño para la FPGA.
    
    \item \textbf{Programación de la FPGA:} Una vez generado el archivo .bit, puedes utilizarlo para programar la FPGA. Conecta la FPGA a tu computadora y utiliza el software de programación de Vivado para cargar el archivo .bit en la FPGA.
\end{enumerate}

Con estos pasos, habrás completado tanto la simulación del diseño en Vivado como la generación del archivo .bit para programar la FPGA.

\textbf{Nota:} El trabajo desarrollado se realizó sobre una FPGA de la firma Xilinx. La placa de desarrollo utilizada es la Arty Z7-10 de la empresa Digilent.

\end{document}

El sistema Realità, al ser un sistema autónomo para la captura de información topográfica, presenta diversos estados durante su funcionamiento. Para una mejor comprensión del sistema, se detallan a continuación los estados principales:

\begin{enumerate}

\item Estado de inicio:

\begin{enumerate}
    \item El sistema se encuentra inactivo, a la espera de instrucciones.
    \item Los sensores están desactivados y no se está capturando información.
    \item El sistema espera la interacción del usuario para iniciar el proceso de captura.
\end{enumerate}

\item Estado de configuración:

\begin{enumerate}
    \item Se configuran los parámetros de operación de cada sensor, como la frecuencia de muestreo, la resolución y el rango de medición, de acuerdo con las características del área de captura y los requerimientos del usuario.

    \item El sistema valida los parámetros ingresados y se prepara para la captura.
\end{enumerate}

\item Estado de captura:

\begin{enumerate}

    \item Se realiza la calibración interna de los sensores para garantizar la precisión y confiabilidad de las mediciones.
     \item Los sensores comienzan a capturar datos de forma simultánea, registrando mediciones de su respectiva naturaleza.

\end{enumerate}

\item Estado de procesamiento:

\begin{enumerate}
    \item El sistema fusiona los datos de los diferentes sensores en tiempo real.
    \item Los datos capturados se procesan y analizan para generar un mapa topográfico preciso.
    \item Se identifican y clasifican los elementos del entorno, como edificios, calles y vegetación.
    \item Se generan metadatos que describen el mapa y las condiciones de captura.
\end{enumerate}

\item Estado de finalización:

\begin{enumerate}
    \item La captura de datos y el procesamiento finalizan.
    \item El sistema presenta al usuario el mapa topográfico generado, junto con los metadatos correspondientes.
    \item El usuario puede guardar el mapa y los metadatos para su posterior uso.
\end{enumerate}

\item Estado de error:

\begin{enumerate}
    \item El sistema entra en este estado si se produce un error durante la captura, el procesamiento o la finalización del proceso.
    \item Se registra el tipo de error y la causa probable.
    \item El usuario es notificado sobre el error y se le proporcionan instrucciones para resolverlo.
\end{enumerate}

\end{enumerate}

\subsection{Definición de los eventos}
\label{sec:descripcion-general}

En el sistema Realità, los eventos que desencadenan las transiciones entre los diferentes estados son acciones o situaciones específicas que determinan el cambio de estado del sistema. Estos eventos pueden ser generados por el usuario, por los sensores o por el propio sistema como resultado de su funcionamiento.

A continuación, se detalla la lista de eventos que desencadenan cada estado:

\begin{enumerate}

\item Estado de inicio:
\begin{enumerate}
    \item Evento de inicio: el usuario enciende el sistema o inicia una nueva sesión de captura.
\end{enumerate}

\item Estado de configuración:
\begin{enumerate}
    \item Evento de inicio de configuración: el usuario accede al menú de configuración del sistema.
    \item Evento de modificación de parámetros: el usuario modifica los parámetros de captura, como el área de interés, la resolución deseada o el tipo de sensores a utilizar.
    \item Evento de validación de parámetros: el sistema valida los parámetros ingresados por el usuario.
    \item Evento de preparación para la captura: el sistema se prepara para iniciar la captura de datos de acuerdo con los parámetros configurados.
\end{enumerate}

\item Estado de captura:

\begin{enumerate}
    \item Evento de inicio de captura: el usuario da la orden de iniciar la captura de datos.
    \item Evento de activación de sensores: los sensores se activan y comienzan a capturar datos.
    \item Evento de calibración interna: se realiza la calibración interna de los sensores para garantizar la precisión y confiabilidad de las mediciones.
    \item Evento de captura de datos: los sensores capturan datos de forma simultánea, registrando mediciones de su respectiva naturaleza.
    \item Evento de fusión de datos en tiempo real: el sistema fusiona los datos de los diferentes sensores en tiempo real.
\end{enumerate}

\item Estado de procesamiento:
\begin{enumerate}
    \item Evento de finalización de captura: se alcanza el área de captura definida o se agota el tiempo de captura.
    \item Evento de inicio de procesamiento: los datos capturados están listos para ser procesados.
    \item Evento de procesamiento de datos: el sistema procesa y analiza los datos capturados para generar un mapa topográfico preciso.
    \item Evento de identificación y clasificación de elementos: se identifican y clasifican los elementos del entorno, como edificios, calles y vegetación.
    \item Evento de generación de metadatos: se generan metadatos que describen el mapa y las condiciones de captura.
\end{enumerate}

\item Estado de finalización:
\begin{enumerate}
    \item Evento de finalización de procesamiento: el procesamiento de datos finaliza y el mapa topográfico está generado.
    \item Evento de presentación del mapa: el sistema presenta al usuario el mapa topográfico generado, junto con los metadatos correspondientes.
    \item Evento de guardado del mapa: el usuario guarda el mapa y los metadatos para su posterior uso.
\end{enumerate}

\item Estado de error:
\begin{enumerate}
    \item Evento de detección de error: se produce un error durante la captura, el procesamiento o la finalización del proceso.
    \item Evento de registro de error: se registra el tipo de error y la causa probable.
    \item Evento de notificación de error: el usuario es notificado sobre el error y se le proporcionan instrucciones para resolverlo.
\end{enumerate}

\item Consideraciones adicionales:

\begin{enumerate}
    \item En algunos casos, un evento puede desencadenar la transición a más de un estado. Por ejemplo, el evento de detección de error puede desencadenar la transición al estado de error y al estado de finalización, dependiendo de la gravedad del error.
    \item El sistema puede incluir mecanismos de recuperación de errores para intentar resolver los errores y volver al estado anterior.
    \item La secuencia de eventos puede variar dependiendo de la configuración del sistema y las condiciones de funcionamiento.
\end{enumerate}

\end{enumerate}



\begin{table}[htbp]
\centering
\caption{Tabla de estados y eventos del sistema}
\resizebox{0.95\textwidth}{!}{%
\begin{tabular}{|p{2.5cm}|p{5cm}|p{3.5cm}|p{7cm}|}
\hline
\textbf{Estado} & \textbf{Evento} & \textbf{Siguiente Estado} & \textbf{Descripción} \\ \hline
Inicio & Inicio del sistema & Configuración & El usuario enciende el sistema o inicia una nueva sesión de captura. \\
 & Modificación de parámetros & Configuración & El usuario modifica los parámetros de captura. \\
 & Validación de parámetros & Configuración & El sistema valida los parámetros ingresados por el usuario. \\ \hline
Configuración & Preparación para la captura & Captura & El sistema se prepara para iniciar la captura de datos. \\ \hline
Captura & Inicio de captura & Captura & El usuario da la orden de iniciar la captura de datos. \\
 & Activación de sensores & Captura & Los sensores se activan y comienzan a capturar datos. \\
 & Calibración interna & Captura & Se realiza la calibración interna de los sensores. \\
 & Captura de datos & Captura & Los sensores capturan datos simultáneamente. \\
 & Fusión de datos en tiempo real & Captura & El sistema fusiona los datos de los sensores. \\
 & Finalización de captura & Procesamiento & Se alcanza el área de captura definida o se agota el tiempo de captura. \\ \hline
Procesamiento & Inicio de procesamiento & Procesamiento & Los datos capturados están listos para ser procesados. \\
 & Procesamiento de datos & Procesamiento & El sistema procesa y analiza los datos capturados. \\
 & Identificación y clasificación de elementos & Procesamiento & Se identifican y clasifican los elementos del entorno. \\
 & Generación de metadatos & Procesamiento & Se generan metadatos que describen el mapa y las condiciones de captura. \\
 & Finalización de procesamiento & Finalización & El procesamiento de datos finaliza y el mapa topográfico está generado. \\ \hline
Finalización & Presentación del mapa & Finalización & El sistema presenta al usuario el mapa topográfico generado. \\
 & Guardado del mapa & Finalización & El usuario guarda el mapa y los metadatos para su posterior uso. \\ \hline
Cualquiera & Detección de error & Error & Se produce un error durante el proceso. \\
 & Registro de error & Error & Se registra el tipo de error y la causa probable. \\
 & Notificación de error & Error & El usuario es notificado sobre el error y se le proporcionan instrucciones. \\ \hline
\end{tabular}%
}
\end{table}

\subsection{Componer el árbol de transiciones}
\label{sec:requisitos-especificos}

El árbol de transiciones es una representación visual que muestra todas las posibles transiciones entre los estados del sistema y los eventos que las desencadenan. Esta representación visual es útil para comprender mejor la estructura del sistema y diseñar casos de prueba efectivos.

Para componer el árbol de transiciones del sistema Realità, primero se identifican todos los estados y eventos. Luego, se trazan las transiciones entre ellos de acuerdo con las reglas definidas. Una vez completado el árbol de transiciones, se puede visualizar de manera clara cómo interactúan los diferentes elementos del sistema en respuesta a diversos eventos.



\subsection{Creación de casos de prueba legales}
\label{sec:requisitos-especificos}

Los casos de prueba legales son aquellos que verifican el comportamiento correcto del sistema cuando se presentan eventos válidos. Estos casos de prueba están diseñados para probar todas las transiciones permitidas entre estados y asegurarse de que el sistema responda correctamente a cada evento.

Para crear los casos de prueba legales para el sistema Realità, se identifican todos los eventos válidos y se diseñan casos de prueba específicos para cada uno de ellos. Estos casos de prueba deben cubrir todas las transiciones entre estados permitidas por el sistema, verificando que el sistema se comporte según lo esperado en cada situación.


\begin{table}[htbp]
    \centering
    \caption{Casos de prueba para Realità}
    \label{tab:casos_prueba}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \textbf{ID} & \textbf{Evento} & \textbf{Guardia} & \textbf{Acción} & \textbf{Estado Inicial} & \textbf{Resultado Esperado} \\
    \hline
    1 & Inicio del sistema & - & - & Inicio & Configuración \\
    \hline
    2 & Modificación de parámetros & - & - & Configuración & Configuración \\
    \hline
    3 & Validación de parámetros & - & - & Configuración & Preparación para la captura \\
    \hline
    4 & Inicio de captura & - & - & Captura & Captura \\
    \hline
    5 & Activación de sensores & Sensores activos & - & Captura & Captura \\
    \hline
    6 & Calibración interna & Sensores calibrados & - & Captura & Captura \\
    \hline
    7 & Captura de datos & Datos capturados & - & Captura & Captura \\
    \hline
    8 & Fusión de datos en tiempo real & Datos fusionados & - & Captura & Procesamiento \\
    \hline
    9 & Inicio de procesamiento & Procesamiento iniciado & - & Procesamiento & Procesamiento \\
    \hline
    10 & Procesamiento de datos & Datos procesados & - & Procesamiento & Procesamiento \\
    \hline
    11 & Identificación y clasificación de elementos & Elementos identificados & - & Procesamiento & Procesamiento \\
    \hline
    12 & Generación de metadatos & Metadatos generados & - & Procesamiento & Procesamiento \\
    \hline
    13 & Finalización de procesamiento & Procesamiento finalizado & - & Procesamiento & Finalización \\
    \hline
    14 & Presentación del mapa & Mapa presentado & - & Finalización & Finalización \\
    \hline
    15 & Guardado del mapa & Mapa guardado & - & Finalización & Finalización \\
    \hline
    16 & Detección de error & Error detectado & - & Finalización & Error \\
    \hline
    \end{tabular}
    }
\end{table}

\subsection{Creación de casos de prueba ilegales}
\label{sec:requisitos-especificos}

Los casos de prueba ilegales son aquellos que prueban el comportamiento del sistema cuando se presentan eventos inválidos o inesperados. Estos casos de prueba están diseñados para evaluar cómo el sistema maneja situaciones incorrectas y asegurarse de que responda de manera adecuada, como mostrar mensajes de error o tomar medidas correctivas.

Para crear los casos de prueba ilegales para el sistema Realità, se identifican eventos que podrían causar transiciones no permitidas entre estados o situaciones incoherentes en el sistema. Luego se diseñan casos de prueba específicos para estos eventos, verificando que el sistema maneje adecuadamente estas condiciones inesperadas.

\begin{table}[htbp]
    \centering
    \caption{Casos de prueba ilegales para Realità}
    \label{tab:casos_prueba_ilegales}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{No.} & \textbf{Configuración} & \textbf{Estado} & \textbf{Evento} & \textbf{Resultado} \\
    \hline
    1 & - & Inicio & Modificación de parámetros & Error \\
    \hline
    2 & Configuración & Captura & Inicio de captura & Error \\
    \hline
    3 & Captura & Procesamiento & Inicio de procesamiento & Error \\
    \hline
    4 & Procesamiento & Finalización & Presentación del mapa & Error \\
    \hline
    \end{tabular}
    }
\end{table}


\subsection{Creación de casos de prueba para los guardias}
\label{sec:requisitos-especificos}

Los casos de prueba para los guardias son aquellos diseñados para evaluar las condiciones de seguridad y protección del sistema. Estos casos de prueba se centran en verificar que el sistema Realità pueda detectar y responder adecuadamente a situaciones de seguridad, como intentos de acceso no autorizado o manipulación maliciosa de datos.

Para crear los casos de prueba para los guardias en el sistema Realità, se identifican posibles vulnerabilidades o amenazas de seguridad y se diseñan casos de prueba específicos para evaluar la capacidad del sistema para detectar y mitigar estas amenazas. Esto puede incluir pruebas de autenticación de usuarios, cifrado de datos, detección de intrusiones y otras medidas de seguridad.


\begin{table}[htbp]
    \centering
    \caption{Casos de prueba para la detección de errores}
    \label{tab:casos_prueba_errores}
    \begin{tabular}{|c|c|c|c|p{5cm}|}
    \hline
    \textbf{No.} & \textbf{Estado Inicial} & \textbf{Evento} & \textbf{Estado Siguiente} & \textbf{Descripción del Caso de Prueba} \\
    \hline
    1 & Inicio & Detección de error & Error & Verificar que el sistema maneje correctamente la detección de un error al iniciar. \\
    \hline
    2 & Configuración & Registro de error & Error & Verificar que el sistema registre adecuadamente un error durante la configuración. \\
    \hline
    3 & Captura & Detección de error & Error & Verificar que el sistema maneje correctamente la detección de un error durante la captura. \\
    \hline
    4 & Procesamiento & Detección de error & Error & Verificar que el sistema maneje adecuadamente la detección de un error durante el procesamiento. \\
    \hline
    5 & Finalización & Detección de error & Error & Verificar que el sistema maneje correctamente la detección de un error durante la finalización. \\
    \hline
    \end{tabular}
\end{table}


\section{Bases del test}
\label{sec:orgc1c4017}

Esta sección proporciona una visión general del proyecto, incluyendo los siguientes aspectos:


\subsection{Especificaciones del producto}
\subsubsection{Diseño funcional general}

El diseño funcional general ofrece una descripción panorámica de las funciones clave del producto, abordando sus características y capacidades fundamentales.

\subsubsection{Diseño funcional detallado}

Este documento detallado presenta una visión a profundidad de las funciones específicas del producto, proporcionando información pormenorizada sobre su implementación y operación.

\subsubsection{Guía del usuario Realità}

La guía del usuario Realità se presenta como un manual exhaustivo destinado a los usuarios finales, contiene instrucciones detalladas para aprovechar al máximo las capacidades del producto, garantizando una experiencia de usuario óptima.

\subsection{Normas}
\subsubsection{Normas internas para productos de prueba}

Establecemos normas internas que actúan como directrices esenciales para la creación y ejecución de productos de prueba, asegurando coherencia y calidad en todo el proceso.

\subsubsection{Libro Testing Embedded Software}

Este libro representa una fuente de referencia esencial que aborda las mejores prácticas en pruebas de software integrado, su contenido se utiliza como guía para garantizar un enfoque sólido y eficiente en la fase de pruebas.

\subsection{Manuales de usuario}
\subsubsection{Manual del entorno de prueba del usuario}

Este manual ofrece instrucciones detalladas sobre el entorno de prueba, proporcionando a los usuarios información clara y completa para una interacción efectiva con el sistema.

\subsubsection{Manual de herramientas de prueba del usuario}

La guía sobre las herramientas de prueba ofrece información detallada sobre las herramientas utilizadas en el proceso de prueba, asegurando una comprensión profunda de su funcionamiento y aplicación.

\subsection{Planes del proyecto}
\subsubsection{Plan de proyecto Realità}

En el plan de proyecto Realità, se detallan todos los aspectos relacionados con la gestión y ejecución del proyecto, desde los objetivos hasta la asignación de recursos, proporciona una hoja de ruta integral para el éxito del proyecto.

\subsection{Planificación}
\subsubsection{Planificación del equipo de desarrollo Realità}

La planificación detallada del equipo de desarrollo para Realità establece la estructura temporal y las tareas asignadas, garantizando una ejecución eficiente y coordinada de las actividades del equipo durante todo el proyecto.


\section{Estrategía general del test}
\label{sec:orgc1c4017}

La estrategia de pruebas de aceptación para Realità se basa en la premisa de que las pruebas de módulos y de integración son realizadas por el equipo de desarrollo. Esta estrategia se ha elaborado después de reuniones con el comisionado, líder del trabajo y gerente de pruebas específicamente para el desarrollo del trabajo Realità.


\subsection{Características de calidad y su importancia relativa}
\label{sec:org24980a8}



Subcaracterísticas seleccionadas:

\begin{enumerate}

\item Idoneidad (Suitability): verificación de que las funcionalidades e interfaces cumplan con los requisitos establecidos.

\item Operabilidad (Operability): evaluación de la interfaz de usuario en términos de simplicidad e intuición.

\item Precisión (Accurateness): mantenimiento de la precisión de los valores medidos en diversas condiciones de funcionamiento.

\item Eficiencia (Time Behaviour): garantizar que el tiempo de respuesta ante eventos críticos sea aceptable.

\item Mantenibilidad (Changeability): facilitar la actualización y adaptación del software.

\end{enumerate}

\subsection{Matriz de estrategia para Realità}
\label{sec:org24980a8}

Realità, como sistema autónomo diseñado para la captura eficiente y precisa de información topográfica, despliega diversas funciones esenciales para cumplir con los objetivos del proyecto.


\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
    \hline
    Subsistema & Funcionalidad  & Usabilidad & Eficiencia & Mantenibilidad \\
    \hline
    SAD & ++ & ++ & + &  \\
    SP & ++ & + & ++ & + \\
    SFD3D & ++ & ++ & ++ & ++ \\
    SC & + & ++ & + & ++\\
    \hline
    Importancia relativa (100) & 40 & 20 & 25 & 15\\
    \hline
\end{tabular}
\end{table}

\subsection*{Referencias}

\begin{itemize}
    \item ++ La característica de calidad es predominante para el subsistema.
    \item + La característica de calidad es relevante para el subsistema.
    \item (vacío) La característica de calidad es insignificante para el subsistema.
\end{itemize}


A continuación, se detallan los subsistemas funcionales clave de Realità en relación con la captura de datos topográficos:

\begin{enumerate}

\item \textbf{Subsistema adquisición de datos (SAD)}
\begin{enumerate}
\item Realità emplea una variedad de sensores y controladores para garantizar una captura eficiente de datos topográficos:
\begin{itemize}
\item Sensores LiDAR: utilizados para la detección remota y la generación de modelos tridimensionales precisos del entorno.
\item Sensores GPS: proporcionan información geoespacial precisa para la localización y el mapeo del terreno.
\item Sensores de imagen con profundidad: permiten la captura de imágenes tridimensionales del entorno con información de profundidad.
\item Sensores IMU (Unidad de Medición Inercial): utilizados para medir y registrar los movimientos y la orientación del dispositivo en tiempo real.
\item Controladores de movimiento: responsables de coordinar y controlar los movimientos del dispositivo para garantizar una captura precisa y eficiente de los datos topográficos.
\end{itemize}

\end{enumerate}

Estos componentes trabajan en conjunto para proporcionar una captura de datos integral y precisa, permitiendo a Realità cumplir con sus objetivos de manera efectiva.

\item \textbf{Subsistema de procesamiento de datos (SP)}
\begin{enumerate}

\item \textbf{Microcontrolador (MC):} el microcontrolador STM32 integra toda la información de los sensores y coordina el procesamiento de datos para su posterior análisis y utilización.
\end{enumerate}

\item \textbf{Subsistema de fusión de datos 3D (SFD3D)}
\begin{enumerate}

\item \textbf{Generador de Nube de Puntos 3D:} este componente genera la nube de puntos 3D a partir de los datos fusionados, proporcionando una representación detallada del terreno topográfico.

\item \textbf{Clasificación de Puntos 3D:} este algoritmo clasifica los datos capturados por los diferentes sensores para crear una representación tridimensional precisa del entorno.
\end{enumerate}

\item \textbf{Subsistema de comunicación (SC)}
\begin{enumerate}
\item \textbf{Sensores Wi-Fi, Bluetooth y de radio:} estos sensores permiten la comunicación inalámbrica para la coordinación, manejo, inicio y finalización de la información entre Realità y otros dispositivos o estaciones base.
\end{enumerate}

\item \textbf{Integración sinérgica del sistema completo}
\begin{enumerate}
\item \textbf{Integración holística para una captura integral:} la integración completa que proporciona una solución holística, maximizando la eficiencia y precisión en la captura de datos topográficos alineados con los requerimientos del proyecto.
\end{enumerate}

\end{enumerate}


\subsection{Técnicas de diseño de pruebas}

Las técnicas de diseño de pruebas desempeñan un papel crucial en el proceso de aseguramiento de la calidad de Realità, estas técnicas proporcionan el marco fundamental para evaluar la funcionalidad, usabilidad, confiabilidad y precisión del sistema autónomo de captura de información topográfica.

En el contexto específico de Realità, las técnicas de diseño de pruebas se adaptan de manera precisa y meticulosa para abordar los desafíos únicos asociados con la integración de sensores multimodales, como GPS, LIDAR, sensor de imagen e IMU.

\subsubsection{Pruebas de funcionalidad}

\textbf{Descripción:} verificar la funcionalidad de cada componente del sistema Realità, incluyendo la captura de datos, procesamiento y generación de mapas.

\textbf{Técnicas:}
\begin{enumerate}
    \item Pruebas unitarias: evaluar cada módulo individualmente.
    \item Pruebas de integración: verificar la interacción entre módulos, especialmente en la fusión de datos de múltiples sensores.
    \item Pruebas de sistema: validar la funcionalidad del sistema en su conjunto.
\end{enumerate}

\subsubsection{Pruebas de usabilidad}

\textbf{Descripción:} evaluar la facilidad de uso del sistema Realità para los usuarios finales, centrándose en la interpretación de los mapas generados.

\textbf{Técnicas:}
\begin{enumerate}
    \item Pruebas de interfaz de usuario (UI): Evaluar la interfaz para asegurar una experiencia intuitiva.
    \item Pruebas de navegación: verificar la facilidad de movimiento y acceso a funciones clave.
\end{enumerate}

\subsubsection{Pruebas de confiabilidad}

\textbf{Descripción:} asegurarse de que Realità produce resultados precisos y consistentes bajo diversas condiciones.

\textbf{Técnicas:}
\begin{enumerate}
    \item Pruebas de estabilidad: evaluar la capacidad del sistema para manejar cargas de trabajo sostenidas.
    \item Pruebas de estrés: exponer el sistema a condiciones extremas para evaluar su comportamiento.
\end{enumerate}

\subsubsection{Pruebas de fusión de datos}

\textbf{Descripción:} garantizar que la integración de datos de sensores GPS, LIDAR, sensor de imagen e IMU genere mapas detallados y precisos.

\textbf{Técnicas:}
\begin{enumerate}
    \item Pruebas de fusión de datos 3D: evaluar la capacidad del sistema para generar representaciones tridimensionales precisas.
    \item Pruebas de coherencia de datos: verificar que los datos de diferentes sensores se integren de manera coherente.
\end{enumerate}

\subsubsection{Pruebas de captura de datos en campo}

\textbf{Descripción:} evaluar el rendimiento de Realità durante la captura de datos topográficos en situaciones del mundo real.

\textbf{Técnicas:}
\begin{enumerate}
    \item Pruebas de campo simuladas: emular condiciones del mundo real para evaluar la precisión y eficacia de la captura de datos.
\end{enumerate}


\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Prueba} &\textbf{Idoneidad} & \textbf{Operabilidad} & \textbf{Precisión} & \textbf{Tiempo} & \textbf{Cambiabilidad}\\
\hline
Unitarias & & ++ & + & + & + \\
Integración & & ++ & & ++ &   \\
Sistema & & + & ++ & ++ & \\
UI & & & ++ & &\\
Navegación & & & ++ &  & \\
Estabilidad & & + & ++ &  &\\
Estrés & & + & ++ & & \\
SFD3D & ++ & ++ & ++ & ++ & \\
Coherencia  & & & ++ & &\\
Simuladas & & ++ & ++ & ++ & ++\\
\hline
\end{tabular}
\caption{Matriz de Técnicas de Diseño para Pruebas en Realità}
\label{tab:design_techniques_matrix}
\end{table}


\subsection{Esfuerzo estimado}

La estimación de esfuerzo es un componente vital en la planificación de pruebas de aceptación para el proyecto Realità, al abordar la complejidad y amplitud del sistema autónomo de captura de datos topográficos, es esencial prever y asignar recursos de manera precisa.

Esta subsección se centra en la evaluación cuidadosa de las tareas relacionadas con las pruebas, considerando factores como la magnitud de la implementación, la diversidad de las técnicas de prueba y las posibles contingencias, una estimación realista y fundamentada no solo facilita la asignación adecuada de recursos, sino que también sirve como un indicador crucial para evaluar la viabilidad temporal y financiera del proyecto Realità.

\begin{table}[h]
\centering
\begin{tabular}{|l |r|}
\hline
\textbf{Actividad} & \textbf{Esfuerzo (horas)} \\
\hline
Plan de pruebas & 20 \\
Fase de planificación y control & 80 \\
Gerencia de pruebas & 48 \\
Gerencia de configuración de pruebas & 28 \\
Soporte metodológico & 44 \\
Fase de preparación & 32 \\
Fase de especificación & 80 \\
Fase de ejecución & 200 \\
Fase de finalización & 16 \\
\hline
\textbf{Total} & \textbf{548} \\
\hline
\end{tabular}
\caption{Esfuerzo estimado para el proceso de pruebas}
\label{tab:estimated_effort}
\end{table}


\subsection{Planificación}

La planificación meticulosa es esencial para el éxito de cualquier proyecto, y las pruebas de aceptación para Realità no son la excepción, en esta fase, se delinea un camino claro que abarca desde la elaboración del plan de pruebas hasta la finalización del informe de resultados y conclusiones, cada actividad se ha calendarizado de manera estratégica para cumplir con el ambicioso objetivo de completar el proyecto dentro del periodo del 10 de marzo al 30 de junio.

Con un enfoque organizado y detallado, se busca asegurar la eficiencia y efectividad en cada etapa del proceso, contribuyendo así al desarrollo exitoso del sistema autónomo de captura de datos topográficos.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Actividad} & \textbf{Inicio} & \textbf{Fin} & \textbf{Responsable} \\
\hline
Plan de pruebas & 10/03 & 19/03 & Equipo de Pruebas \\
\hline
\multicolumn{4}{|c|}{\textbf{Fase de Planificación}} \\
\hline
Elaboración del documento de plan de pruebas & 20/03 & 31/03 & Líder de Pruebas \\
Revisión del plan con el equipo & 01/04 & 09/04 & Equipo de Pruebas \\
Configuración de pruebas & 10/04 & 23/04 & Ingeniero de Configuración \\
Soporte metodológico & 24/04 & 07/05 & Especialista en Metodología \\
\hline
\multicolumn{4}{|c|}{\textbf{Fase de Preparación}} \\
\hline
Elaboración de casos de prueba & 15/03 & 31/03 & Analista de Pruebas \\
Revisión de casos de prueba & 01/04 & 03/04 & Equipo de Pruebas \\
\hline
\multicolumn{4}{|c|}{\textbf{Fase de Ejecución}} \\
\hline
Ejecución de pruebas & 10/05 & 26/05 & Equipo de Pruebas \\
\hline
\multicolumn{4}{|c|}{\textbf{Fase de Finalización}} \\
\hline
Informe de resultados y conclusiones & 27/05 & 28/05 & Líder de Pruebas \\
\hline
\end{tabular}
\caption{Planificación de Pruebas de Aceptación para \textit{Realità}}
\label{tab:planning}
\end{table}

\section{Amenazas, riesgos y medidas}

El entorno de pruebas para el proyecto Realità no está exento de desafíos potenciales y riesgos que podrían afectar el éxito de las pruebas de aceptación, por lo anterior se hace necesario identificar, evaluar y gestionar estas amenazas de manera proactiva garantizado la integridad y la eficacia del proceso de prueba.

En esta subsección, se abordarán posibles amenazas y riesgos, desde limitaciones tecnológicas hasta cambios inesperados en los requisitos, y se propondrán medidas mitigadoras específicas.

\begin{enumerate}
  \item Posible retraso en la entrega a prueba: en caso de retrasos, se utilizará la estrategia de prueba para determinar las pruebas omitidas, asegurando una cobertura adecuada incluso bajo restricciones de tiempo.
  \item Equipo de desarrollo disuelto después de la entrega: se garantizará la presencia de al menos un desarrollador experimentado durante la ejecución de pruebas para abordar cualquier problema inesperado y mantener el conocimiento del sistema.
  \item Disponibilidad limitada del experto de dominio: se planificará de manera adecuada, anticipando posibles retrasos y asegurando la máxima disponibilidad del experto de dominio cuando sea necesario.
  \item Diseñadores trabajando en el diseño funcional y guías de usuario: se garantizará la disponibilidad oportuna de los diseñadores para mantener la coherencia y reproducibilidad en el diseño funcional y las guías de usuario.
\end{enumerate}

\section{Infraestructura}

\subsection{Entorno de pruebas}

El equipo de pruebas está compuesto por cinco personas, durante el proyecto de prueba, se debe disponer de dos (2) PC con una configuración de hardware estándar y el software estándar utilizado por Solidly Embedded Ltd. (para software especial, consulte la sección) que requiere un espacio mínimo de 20 GB en el directorio de gestión del producto.

\subsection{Herramientas de pruebas}

Las siguientes herramientas de prueba son esenciales:

\begin{enumerate}
  \item Herramienta de gestión de defectos \textit{DefectTracker}.
  \item Herramienta de gestión de cambios \textit{ChangeMaster}.
  \item Software de planificación.
  \item Hardware adicional para rastrear el comportamiento interno eferente a la captura de información topográfica.
\end{enumerate}

\subsection{Entorno}

Se utiliza el entorno de prueba estándar, los probadores utilizan su espacio de oficina y campo durante el proyecto de prueba.

\section{Organización de pruebas}

\subsection{Roles de pruebas}

Los siguientes roles de prueba son necesarios en este proyecto:

\begin{enumerate}
  \item Ingeniero de pruebas.
  \item Gerente de pruebas.
  \item Soporte metodológico.
  \item Soporte técnico.
  \item Experto en dominio.
  \item Gerente de configuración de pruebas.
\end{enumerate}


\subsection{Personal de Pruebas}

\begin{table}[h]
\centering
\begin{tabular}{|l |l |l|}
\hline
\textbf{Función} & \textbf{Nombre} & \textbf{Equivalente a Tiempo Completo} \\
\hline
Gerente de Pruebas & T. Testware & 0.20 \\
Probador & P. Testcase & 1.00 \\
Probador & F. Testscript & 1.00 \\
Soporte & G. Allround & 1.00 \\
Experto en Dominio & A. Experto & 0.60 (durante la ejecución de pruebas) \\
\hline
\end{tabular}
\caption{Funciones y equivalente a tiempo completo del personal de pruebas}
\label{tab:test_staff}
\end{table}


\section{Entregables de pruebas}

\subsection{Documentación del proyecto}

Se producirán los siguientes documentos durante el proyecto de prueba:

\begin{enumerate}
  \item Plan de pruebas: el documento inicial y todas sus versiones anteriores/futuras.
  \item Informes de defectos: se informan todos los defectos observados.
  \item Informes semanales: informes de progreso realizados por el gerente de pruebas.
  \item Recomendación para la liberación: formalmente es el final de la fase de ejecución de pruebas.
  \item Informe de revisión: este informe da una evaluación del proceso de pruebas durante el proyecto.
\end{enumerate}

\subsection{Testware}

Los siguientes documentos son entregables del proyecto de prueba:

\begin{enumerate}
  \item Guion de pruebas: una descripción de cómo se realiza la prueba. Contiene acciones y verificaciones, relacionadas con casos de prueba, indicando la secuencia de ejecución.
  \item Escenario de pruebas: un micro-plan de pruebas que coordina la ejecución de varios guiones de prueba y asigna probadores a los guiones de prueba.
  \item Conjunto de datos inicial: archivos y conjuntos de datos necesarios para iniciar ciertas pruebas.
\end{enumerate}

\subsection{Almacenamiento}

La estructura de directorios mostrada en la Tabla \ref{tab:directory_structure} está implementada en el servidor central de Solidly Embedded Ltd, el directorio se almacena en el directorio de gestión de productos: \texttt{\textbackslash\textbackslash PROD\_MANAG}.

\begin{table}[h]
\centering
\begin{tabular}{|l| l|}
\hline
\textbf{Directorio} & \textbf{Contenido} \\
\hline
\texttt{ACC\_TEST\_REALITA} & Directorio principal del proyecto \\
\texttt{PROCDOC} & Documentación del proyecto \\
\texttt{WORK\_TESTWARE} & Directorio de trabajo para testware \\
\texttt{FINAL\_TESTWARE} & Directorio para archivar testware \\
\texttt{DEFECTS} & Base de datos para el almacenamiento de defectos \\
\texttt{OTHER} & Todos los demás documentos utilizados o producidos \\
\hline
\end{tabular}
\caption{Estructura de directorios}
\label{tab:directory_structure}
\end{table}

\section{Gestión de configuración}

\subsection{Control del proceso de pruebas}

El progreso de las pruebas y el agotamiento del presupuesto y el tiempo se monitorean y informan durante el proyecto de pruebas. Esto se realiza semanalmente y los resultados se informan en la reunión semanal de progreso.

\subsection{Gestión de defectos}

Para la gestión de defectos, se utiliza la herramienta "DefectTracker", se sigue el procedimiento estándar de defectos (SolEmb 76.1 "Procedimiento de defectos").

\subsection{Métricas}

El jefe de pruebas realiza un seguimiento de las siguientes métricas:

\begin{enumerate}
    \item Número de defectos abiertos por categoría de gravedad en un momento dado.
    \item Número de defectos resueltos en un período por categoría de gravedad.
    \item Número total de defectos detectados.
    \item Número de retrabajos por defecto.
    \item Número total de retrabajos.
\end{enumerate}

\subsection{Ítems de gestión de configuración}

El plan de pruebas está sujeto a la gestión de configuración, comenzando con la primera versión completa. El resto del testware se somete a la gestión de configuración después de la fase de finalización. Los cambios en la infraestructura de pruebas están sujetos a la gestión de configuración del departamento de soporte técnico de Solidly Embedded Ltd.



\newpage


\section{Bibliografía}

\begin{enumerate}
      \item Bart Broekman, Edwin Notenboom. \emph{Testing Embedded Software}. Addison-Wesley Professional, 2003. ISBN: 978-0201795238
  % Agrega más referencias según sea necesario
\end{enumerate}



\end{document}
